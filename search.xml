<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《数据结构和算法分析 C语言描述》笔记#0 写在前面</title>
    <url>/reports/f165f6af4c15/</url>
    <content><![CDATA[<ul>
<li>这是什么</li>
</ul>
<p>  这是笔者在阅读《数据结构和算法分析 C语言描述》过程中和过程后写下的笔记，并不一定完善，且可能存在错误之处，故仅作参考之用，望海涵。</p>
<p>  顺带一提，笔者使用的版本为中文第二版。</p>
<ul>
<li>什么人该读这本书</li>
</ul>
<p>  对数据结构和算法有浓厚兴趣或者将它作为一些难度更高层次更深的相关专业书籍的导读的人。</p>
<ul>
<li>读这本书需要什么</li>
</ul>
<p>  C语言基础（更准确地说，书中算法均用ANSI C表示）、部分离散数学知识和中等程度的程序设计知识（包括但不限于指针和递归等内容）</p>
<ul>
<li>关于如何去读这本书的建议<ol>
<li>整理知识结构和笔记</li>
<li>尽可能地完成章末练习</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构和算法分析 C语言描述》笔记#1 引论</title>
    <url>/reports/576f952bdc28/</url>
    <content><![CDATA[<ol>
<li><h4 id="一个好的算法应该做什么"><a href="#一个好的算法应该做什么" class="headerlink" title="一个好的算法应该做什么"></a>一个好的算法应该做什么</h4><p>在一个合理的时间内尽可能地处理足够多的数据，并且能解决一类问题而不仅仅是对某个偶然情况有用。</p>
</li>
<li><h4 id="数学知识的复习"><a href="#数学知识的复习" class="headerlink" title="数学知识的复习"></a>数学知识的复习</h4><ol>
<li><h5 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h5><script type="math/tex; mode=display">
X^A X^B=X^{A+B}</script><script type="math/tex; mode=display">
\frac{X^A}{X^B}=X^{A-B}</script><script type="math/tex; mode=display">
(X^A)^B=X^{AB}</script><script type="math/tex; mode=display">
X^N+X^N=2X^N \neq X^{2N}</script><script type="math/tex; mode=display">
2^N+2^N=2^{N+1}</script></li>
</ol>
</li>
</ol>
<ol>
<li><h5 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h5><blockquote>
<p>“在计算机科学中，除非有特别声明，所有的对数均以2为底。”</p>
</blockquote>
</li>
</ol>
<script type="math/tex; mode=display">
   \log_AB=\frac{\log_CB}{\log_CA}(C>0)</script><script type="math/tex; mode=display">
   \log_2{AB}=\log_2A+\log_2B</script><script type="math/tex; mode=display">
   \log_2A-\log_2B=\log_2{\frac{A}{B}}</script><script type="math/tex; mode=display">
   \log_2{A^B}=B\log_2A</script><script type="math/tex; mode=display">
   \log_2X<X(X>0)</script><script type="math/tex; mode=display">
   \log_21=0;
    \log_2{1024}=10;
    \log_2{1048576}=20</script><ol>
<li><h5 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h5><ul>
<li><p><strong>几何级数（等比级数）</strong></p>
<script type="math/tex; mode=display">
\sum_{i=0}^N{2^i}=2^{N+1}-1</script><script type="math/tex; mode=display">
\sum_{i=0}^N{A^i}=\frac{A^{N+1}-1}{A^N-1}</script><p>特别的，在第二个公式中 <code>0&lt;A&lt;1</code> 时，</p>
<script type="math/tex; mode=display">
\sum_{i=0}^N{A^i} \leq \frac{1}{1-A}</script><script type="math/tex; mode=display">
\lim_{N\rightarrow\infty}\sum_{i=0}^N{A^i} = \frac{1}{1-A}</script></li>
<li><p><strong>算术级数（等差级数）</strong></p>
<script type="math/tex; mode=display">
如 \sum_{i=1}^Ni=\frac{N(N+1)}{2}</script><script type="math/tex; mode=display">
\sum_{i=1}^Ni^2=\frac{N(N+1)(2N+1)}{6}\approx \frac{N^3}{3}</script><script type="math/tex; mode=display">
\sum_{i=1}^Ni^k\approx\frac{N^{k+1}}{|k+1|}(k\neq -1)</script><p>注： 当k=-1，</p>
<script type="math/tex; mode=display">
\frac{1}{i}为调和（级）数</script></li>
</ul>
</li>
<li><h5 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h5><ul>
<li><p><strong>同余</strong></p>
<script type="math/tex; mode=display">
A\equiv B(\mod N)</script><script type="math/tex; mode=display">
A+C\equiv B+C(\mod N)</script><script type="math/tex; mode=display">
AD\equiv BD(\mod N)</script><p>即N整除A-B，也就是说无论A还是B除以N，所得余数都相同。</p>
<p>如书中所举例子</p>
<script type="math/tex; mode=display">
81\equiv61\equiv1(\mod10)</script></li>
</ul>
</li>
<li><h5 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h5><ul>
<li><strong>归纳法</strong><ol>
<li>证明基准情形(base case)</li>
<li>归纳假设(inductive hypothesis)</li>
</ol>
</li>
<li><p><strong>举反例法</strong></p>
<ol>
<li>举出任意不符合原定理的实例，原定理则不成立。</li>
</ol>
</li>
<li><p><strong>反证法</strong></p>
<ol>
<li>假设定理不成立，再证明该假设导致某个已知性质不成立，从而说明原假设错误。</li>
</ol>
</li>
</ul>
</li>
<li><h5 id="递归简论"><a href="#递归简论" class="headerlink" title="递归简论"></a>递归简论</h5><ul>
<li><h6 id="基本法则"><a href="#基本法则" class="headerlink" title="基本法则"></a>基本法则</h6><ol>
<li><strong>基准情形(base case)</strong>：存在某些不用递归就能求解的情形。</li>
<li><strong>不断推进(making progress)</strong>：需要递归求解的情形，它们的递归调用必须朝着产生基准情形的方向前进（即最后必须转换为基准情形的变体）。</li>
<li><strong>设计法则(design rule)</strong>：假设所有的递归调用都能运行。即不用太过关心计算机是如何具体进行递归调用的，设计者只需要关注逻辑的正确性。</li>
<li><strong>合成效益法则(compound interest rule)</strong>：在求解同一个问题的同一实例时，不要在不同的递归调用中做重复性的工作。换句话说，不要在递归中进行重复的计算，如使用递归计算斐波那契数列和，这样对递归错误的使用会带来大量不必要的开销。</li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构和算法分析 C语言描述》笔记#10 算法设计技巧</title>
    <url>/reports/342f59392f1a/</url>
    <content><![CDATA[<blockquote>
<h4 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h4></blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构和算法分析 C语言描述》笔记#2 算法分析</title>
    <url>/reports/40155a7efa0e/</url>
    <content><![CDATA[<blockquote>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3></blockquote>
<p>为了方便我们分析和设计算法，我们推出一个理想化的计算机模型。</p>
<p>在这个理想模型中，存在以下几条规则：</p>
<ol>
<li><p>该模型做任意一次简单操作都恰好花费一个时间单元。</p>
<ol>
<li><p>该模型如现代计算机一样，整数拥有固定范围（32、64位）</p>
</li>
<li><p>矩阵求逆，排序等运算不算在简单操作内，它们显然花费远超一个时间单元。</p>
</li>
<li><p>该模型拥有无限的内存空间。</p>
<hr>
</li>
</ol>
</li>
</ol>
<blockquote>
<h3 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h3></blockquote>
<ul>
<li><strong>增长率</strong></li>
</ul>
<p>出于对实际应用的考虑，我们一般不对算法作特别具体的分析，相反我们比较算法的<em>相对增长率（relative rate of growth）</em>，这是一种重要的度量。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ C $</td>
<td>常数</td>
</tr>
<tr>
<td>$ \log{N} $</td>
<td>对数级</td>
</tr>
<tr>
<td>$ \log^2{N} $</td>
<td>对数平方级</td>
</tr>
<tr>
<td>$ N $</td>
<td>线性级</td>
</tr>
<tr>
<td>$ N\log^2{N} $</td>
<td></td>
</tr>
<tr>
<td>$ N^2 $</td>
<td>平方级</td>
</tr>
<tr>
<td>$ N^3 $</td>
<td>立方级</td>
</tr>
<tr>
<td>$ 2^N $</td>
<td>指数级</td>
</tr>
<tr>
<td>$ n! $</td>
<td>阶乘</td>
</tr>
</tbody>
</table>
</div>
<p>图 2-1    典型增长率</p>
<ul>
<li><p><strong>渐进符号</strong></p>
<ul>
<li><p>$O$ (Omicron)</p>
<p>书上给出定义： “如果存在正常数$c$和$n_0$使得当$N\geq n^0$时$T(N)\leq cf(N)$，则记为$T(N)=\Omicron(f(N))$。”</p>
<p>也就是说，$T(N)$的增长率<strong>小于等于</strong>$f(N)$的增长率，$f(N)$是$T(N)$的上界（upper bound）。这种记法较为常用，被称为<em>大$O$记法</em>。</p>
</li>
<li><p>$\Omega$ (Omega)</p>
<p>定义： “如果存在正常数$c$和$n_0$使得当$N\geq n^0$时$T(N)\geq cg(N)$，则记为$T(N)=\Omega(g(N))$。”</p>
<p>同理，$T(N)$的增长率<strong>大于等于</strong>$f(N)$的增长率，$f(N)$是$T(N)$的下界（lower bound）。</p>
</li>
<li><p>$\Theta$ (Theta)</p>
<p>定义： “当且仅当$T(N)=O(h(N))$且$T(N)=\Omega(h(N))$，则记为$T(N)=\Theta(g(N))$。”</p>
<p>这种情况意味着两个函数的增长率相等。</p>
</li>
<li><p>$\omicron$ (omicron)</p>
<p>定义： “当且仅当$T(N)=O(p(N))$且$T(N)\neq\Theta(p(N))$，则记为$T(N)=\omicron(p(N))$。”</p>
<p>$T(N)$的增长率<strong>小于</strong>$p(N)$的增长率，不存在增长率相同的可能性。</p>
</li>
<li><p>重要结论</p>
<ol>
<li>如果$T_1(N)=O(f(N))$且$T_2(N)=O(g(N))$，那么<ul>
<li>$T_1(N)+T_2(N)=max(O(f(N)),\quad O(g(N)))$</li>
<li>$T_1(N)<em>T_2(N)=O(f(N)</em>g(N))$</li>
</ul>
</li>
<li>如果$T(N)$是一个k次多项式，则$T(N)=\Theta(N^k)$</li>
<li>对任意常数k，$\log^kN=O(N)$，即对数增长率小于线性，增长十分缓慢。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>计算极限和使用洛必达法则</strong><sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
<p>我们通过计算极限$\lim_{n\rightarrow\infty}\frac{f(N)}{g(N)}$来确定两个函数的相对增长率，必要时可使用洛必达法则。</p>
<ul>
<li>$\lim_{n\rightarrow\infty}\frac{f(N)}{g(N)}=0$ ：这意味着$f(N)=\omicron(g(N))$</li>
<li>$\lim_{n\rightarrow\infty}\frac{f(N)}{g(N)}\neq0$ ：这意味着$f(N)=\Theta(g(N))$</li>
<li>$\lim_{n\rightarrow\infty}\frac{f(N)}{g(N)}=\infty$ ：这意味着$g(N)=\omicron(f(N))$</li>
<li>极限摆动不存在 ：二者无关</li>
</ul>
</li>
<li><p><strong>注意事项</strong></p>
<ul>
<li><p>保证结果尽量的严密</p>
<p>如果$g(N)=2N^2$，那么在$g(N)=O(N^4)、g(N)=O(N^3)、g(N)=O(N^2)$中，我们应该选择最后一个记法，而$g(N)=\Theta(N^2)$不仅表示$g(N)=O(N^2)$，且表示结果会尽可能严密。</p>
</li>
<li><p>不要将常数项或者低阶项放入$O$</p>
<p>错误做法：$T(N)=O(2N^2)或T(N)=O(N^2+N)$</p>
<p>正确做法：$T(N)=O(N^2)$</p>
<p>我们应该在需要$O$的任何分析中，可以进行各种简化。低阶项和常数项一般可以被忽略舍弃，要求的精度并不高。</p>
</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<h3 id="如何分析问题"><a href="#如何分析问题" class="headerlink" title="如何分析问题"></a>如何分析问题</h3></blockquote>
<ul>
<li><p><strong>分析角度</strong></p>
<ul>
<li>（最坏）运行时间</li>
<li>输入大小</li>
</ul>
</li>
<li><p><strong>注意事项</strong></p>
<ul>
<li>不要让你的算法成为问题的瓶颈，你设计的算法应该解决问题而尽量不成为新的问题的致因。</li>
<li>少量输入的情形不需要过于聪明的算法。算法为你的业务需要而服务。  </li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<h3 id="运行时间计算"><a href="#运行时间计算" class="headerlink" title="运行时间计算"></a>运行时间计算</h3></blockquote>
<ol>
<li><p><strong>一般法则</strong></p>
<ol>
<li><p>for循环</p>
<p>一次for循环的运行时间至多是该for循环内语句（包括测试）的运行时间乘以迭代的次数。</p>
</li>
<li><p>嵌套的for循环</p>
<p>由内向外分析这些循环。在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有的for循环的大小的乘积。</p>
<p>如下例，运行时间为$O(N^2)$</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">	<span class="keyword">for</span>( j=<span class="number">0</span>; j&lt;N; j++)</span><br><span class="line">		k++;</span><br></pre></td></tr></table></figure>
<ol>
<li>顺序语句</li>
</ol>
<p>各个语句的运行时间求和，即其中最大值就是所得运行时间。<br>如下例，先用去$O(N)$，再用去$O(N^2)$，所以总的运行时间是$O(N^2)$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">	A[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;N; j++)</span><br><span class="line">		A[i] += A[j]+i+j;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>if/else语句</p>
<p>对于下例，一个if/else语句的运行时间从不超过判断的时间假设S1和S2中运行时间较长者的总的运行时间。运行时间的估计可以过高，但绝不会过低。<sup><a href="#fn_2" id="reffn_2">2</a></sup></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( Condition )</span><br><span class="line">	S1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	S2</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>检验你的分析</strong><ul>
<li>编程并比较实际观察到的运行时间与通过分析所描述的运行时间是否相匹配。<br>  但是值得一提的是，单纯凭借实践在N不够大时区分增长率一开始相差不大的两个程序并不简单。</li>
<li>对N的某个范围（一般是2的倍数隔开）计算比值$T(N)/f(N)$，其中T(N)是凭借经验观察到的运行时间。如果f(N)是运行时间的理想近似，则得到的比值会收敛于一个正常数，若f(N)过大，则比值收敛于0。同理，f(N)过小，比值发散。</li>
</ul>
</li>
</ol>
<blockquote id="fn_1">
<sup>1</sup>. 国内一般会在大学课程《高等数学》中教授相关知识。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. S代表着Statement，也就是语句。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构和算法分析 C语言描述》笔记#3 表、栈和队列</title>
    <url>/reports/bb8f1d957d5f/</url>
    <content><![CDATA[<ul>
<li><h3 id="什么是抽象数据类型-Abstract-Data-Type-ADT"><a href="#什么是抽象数据类型-Abstract-Data-Type-ADT" class="headerlink" title="什么是抽象数据类型(Abstract Data Type, ADT)"></a>什么是抽象数据类型(Abstract Data Type, ADT)</h3><p>出于模块化设计思想，人们将一些操作的集合的数学模型称为ADT。ADT的诞生使得编程更加清晰，程序员只需要通过ADT操作便能方便的操作数据，而这些操作对于程序的其余部分是完全透明的，也就是说其余部分并不需要关注这部分的具体实现。常见的ADT有<strong>表(List)</strong>、<strong>集合(Set)</strong>、<strong>图(Graph)</strong>等。如果读者了解过抽象类(Abstract Class)或接口(Interface)的概念，会很容易接受ADT是抽象事物的事实。</p>
</li>
<li><h3 id="表-List"><a href="#表-List" class="headerlink" title="表(List)"></a>表(List)</h3><p>表可以看作一种容器，这个容器里面容纳了若干元素(element)。一个表拥有多少个元素，它的大小就为多少。当一个表含有0个元素，也就是大小为0时，我们称它为<strong>空表(empty list)</strong>。如前面提到的，ADT是一些操作的集合，对于表来说，我们有下列常见操作（仅举例）：</p>
<p>| 名称              | 作用               |<br>| ————————- | ————————— |<br>| <code>PrintList()</code>     | 打印表             |<br>| <code>Insert(Element)</code> | 插入元素           |<br>| <code>Delete(Element)</code> | 删除元素           |<br>| <code>Find(Element)</code>   | 返回指定元素的位置 |</p>
<p>在这里我们也仅仅是给出了表的概念，但没有给出它的具体实现。事实上，我们对表的所有操作都能用数组来实现。但是由于数组本身性质，使用数组可能会造成大量的空间浪费。而且为了维护表中元素的位置关系，我们还会花费大量时间。所以我们一般不用简单数组来实现表。</p>
<ul>
<li><p>链表(linked list)</p>
<ul>
<li><p>单链表(singly linked list)</p>
<p>当链表没有（单双等）前缀时，一般指的是单链表。链表，顾名思义，表（或者说表中的元素们）以链的形式呈现。即每个单元（元素）不仅含有自己的信息，还有指向下一个单元的指针（Next指针）。最后一个单元因为没有后续单元，指向<code>NULL</code>（ASCII C规定NULL为0）。</p>
<ul>
<li><p>程序实现细节</p>
<ul>
<li><p>添加表头</p>
<p>为了避免删除操作在某些特殊情况下带来的问题，我们可以添加<strong>表头</strong>（<strong>header</strong>，也可称作<strong>哑节点dummy node</strong>）。表头是一个假想的单元，它不包含实际的元素，仅仅当作一个标志。它的使用可以帮助我们表达基本的指针操作，却不会使得特殊情况下代码变得混乱不堪。但是否使用表头取决于程序员自己。</p>
</li>
</ul>
</li>
<li><p>常见错误</p>
<ol>
<li>程序崩溃，系统报错<ul>
<li>错误的使用指针<ol>
<li>初始化变量失败</li>
<li>没有对指针进行<code>NULL</code>检查</li>
<li>出现野指针</li>
</ol>
</li>
<li>错误的分配内存<ol>
<li>当某些内存不再需要时，记得及时<code>free</code></li>
<li>不要无谓的分配内存，当分配内存时注意是否有必要</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>双链表(doubly linked list)</p>
<p>有些时候可能我们需要倒序的扫描链表，这种时候单链表就显得有些无能为力了。为了解决这个问题，我们可以在每个单元上再加上一个指向前一个单元的指针。这增加了时间和空间的开销，但简化了一些操作。</p>
</li>
<li><p>循环链表(circular linked list)</p>
<p>还可以让最后一单元的下一个单元的指针指向第一个单元。这与链表是单链表还是双链表无关，仅仅使得链表形成一个闭环。</p>
</li>
<li><p>游标(cursor)实现链表</p>
<p>一些语言不支持指针，我们可以用游标法来模仿指针。只要能实现下面两条特性即可：</p>
<ol>
<li>数据存储在一组结构体中。每一个结构体包含数据以及指向下一个结构体的指针。</li>
<li>一个新的结构体可以通过调用<code>malloc</code>方法而从系统全局内存(global memory)中得到，并且可以通过<code>free</code>方法释放。</li>
</ol>
</li>
<li><p>应用</p>
<ol>
<li><p>平衡符号</p>
<p>我们可以用栈来检测是否所有括号等成对符号是否成对完整出现。</p>
</li>
<li><p>后缀表达式(postfix)/逆波兰(reverse Polish)表达式</p>
</li>
<li><p>函数调用</p>
<p>比较常见的例子可以参考javascript的执行上下文机制。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>多重表</p>
<ul>
<li><p>数组实现</p>
<p>我们可以用二维数组实现一个网状结构的表。这很容易理解，故不赘述。</p>
</li>
<li><p>链表实现</p>
<p>只要在每个单元上都多加上几个指针，我们就可以实现这个网状结构。</p>
</li>
</ul>
</li>
<li><p>栈(Stack)</p>
<blockquote>
<p>“栈很可能是计算机科学中仅次于数组的最基本的数据结构。”</p>
</blockquote>
<p>栈是一种特殊的表（亦可称作LIFO<sup><a href="#fn_1" id="reffn_1">1</a></sup>表），它的插入和删除操作只能作用在一个固定位置上，只有这个固定位置上的元素是唯一可见的。这个固定的位置是表的末端，被称作栈的<strong>顶(top)</strong>。对栈的基本操作是<code>push(进栈)</code>，<code>pop(出栈)</code>和<code>top(检查顶并返回它的值)</code>。值得一提的是，对空栈进行<code>pop/top</code>都是错误的，一个正确的栈ADT<span style="color: red;">不应该允许这种行为</span>。而push时因为内存空间用尽不够，则是实现错误，与ADT错误无关。</p>
<ul>
<li><p>栈的链表实现$O(1)$</p>
<p>我们可以使用单链表来实现一个简单的栈模型。只需要将表的前端作为栈顶，我们便可以得到一个栈模型。通过链表完成的实现只花费常数时间，但是也带来了<code>malloc</code>和<code>free</code>的昂贵开销。</p>
</li>
<li><p>栈的数组实现$O(1)$</p>
<p>使用一个数组实现栈很简单。它同样花费常数时间（原书写的是“非常快的常数时间”）。</p>
</li>
<li><p>不要忽略错误检测</p>
<p>错误检测的确很影响栈的执行效率，甚至可能会使得时间开销加倍。所以我们一般在栈例程中省去了错误检测。虽然大多数时候程序得以正常运行，但我们应该随时准备好错误检测以防止不必要的损失。</p>
</li>
</ul>
</li>
<li><p>队列(Queue)</p>
<p>在某种意义上，我们可以把队列看作栈的变种。因为它不仅像栈那样拥有一个在表的末端的队尾(rear)，还拥有一个在表的开头的队头(front)，<code>Enqueue(入队)</code>是在队尾插入一个元素，而<code>Dequeue(出队)</code>则是删除或返回队头的元素。</p>
<ul>
<li><p>链表实现</p>
<p>在栈的链表实现上稍作改动，加上队头，我们便可以完成一个简单的队列实现。</p>
</li>
<li><p>循环数组实现</p>
<ul>
<li>注意<ol>
<li>记得检测队列是否为空。</li>
<li>保证你所有的例程的实现方法统一。</li>
</ol>
</li>
</ul>
</li>
<li><p>队列的应用</p>
<ol>
<li>各种各样的排队</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote id="fn_1">
<sup>1</sup>. Last In First Out，即后进先出。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构和算法分析 C语言描述》笔记#4 树</title>
    <url>/reports/81b0f4f897cf/</url>
    <content><![CDATA[<ul>
<li><h2 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h2><p>相比前面提到的链表，本章介绍的树更加适合在拥有大量输入时的线性访问，事实上，它的大部分操作的运行时间都是$O(\log N)$。</p>
<p>我们将树称为树的一个重要原因便是它的结构酷似自然界中的树。定义树的一种自然方法便是递归，一棵非空的树将由一个<code>根节点(root node)</code>。也就是说，一棵非空的树是由若干棵<code>子树(child tree)</code>组成的，而我们将连接这些树或者说节点的联系称为<code>边(edge)</code>。</p>
<ul>
<li><p>父亲(parent)</p>
<p>相对它的子节点而言。</p>
</li>
<li><p>儿子(child)</p>
<p>相对它的父节点而言。</p>
</li>
<li><p>树叶(leaf)</p>
<p>树叶指的是没有子树（节点）的节点。</p>
</li>
<li><p>兄弟(sibling)</p>
<p>拥有同一个父节点的节点互为兄弟。</p>
</li>
<li><p>祖父(grandparent)</p>
<p>父节点的父节点。</p>
</li>
<li><p>孙子(grandchild)</p>
<p>子节点的子节点。</p>
</li>
<li><p>深度(depth)与高度(height)</p>
<blockquote>
<p>注意，当参考系（树的选取）发生变化时，同一个节点的深度或者高度可能也会发生变化。</p>
</blockquote>
<ul>
<li><p>深度</p>
<p>每个节点的深度指的是从根到该节点的唯一路径的长，或者说是经过的边的条数。根的深度为0。</p>
</li>
<li><p>高度</p>
<p>每个节点到一片树叶的最长路径的长。所有的树叶的高都为0。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="树的实现、遍历-traversal-和应用"><a href="#树的实现、遍历-traversal-和应用" class="headerlink" title="树的实现、遍历(traversal)和应用"></a>树的实现、遍历(traversal)和应用</h4><p>如同我们在上一章通过指针实现链表一样，我们也可以用指针实现树的结构。只需要改变一个节点中指向其他节点的指针个数便可以得到简单的树模型。</p>
<p>树的遍历可根据节点处理顺序简单分为<code>先序(preorder)</code>，<code>中序(inorder)</code>和<code>后序(postorder)</code>三种遍历方式。</p>
<ul>
<li><p>先序遍历</p>
<p>对一个节点的处理工作为最最优先，在处理完该节点本身后再处理子节点。</p>
<p>一个典型的应用便是UNIX、VAX/VMS和DOS等系统内的目录。我们可以通过书上提供的一个例程来输出目录结构，这是一个典型的先序遍历：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListDir</span><span class="params">(DirectoryOrFile D, <span class="keyword">int</span> Depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(D is a legitimate entry)</span><br><span class="line">    &#123;</span><br><span class="line">        printName(D, Depth);</span><br><span class="line">        <span class="keyword">if</span>(D is a directory)</span><br><span class="line">            <span class="keyword">for</span> each child, C, of D</span><br><span class="line">                ListDir(C, Depth+<span class="number">1</span>);</span><br><span class="line">              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDirectory</span><span class="params">(DirectoryOrFile D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListDir(D, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>中序遍历</p>
<p>中序遍历仅在二叉树存在，它按照左子树-&gt;自身-&gt;右子树的顺序进行处理。</p>
</li>
<li><p>后序遍历</p>
<p>后序遍历和前序遍历相反，在处理完所有子节点后再处理父节点。</p>
</li>
</ul>
<ul>
<li><h4 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h4><p>二叉树是树的一种，它的特殊之处在于每个节点的子节点数量最多为<code>2</code>。二叉树根据节点的排列情况可以简单地分为斜树、满二叉树、完全二叉树。</p>
<ul>
<li><p>斜树</p>
<p>斜树是所有节点只有左子树或者只有右子树，看起来就像是一条斜线。</p>
</li>
<li><p>满二叉树</p>
<p>除树叶外的所有节点都有左子树和右子树，并且所有树叶同高同深度，因此它是左右对称的。</p>
</li>
<li><p>完全二叉树</p>
<p>左右子树深度差最多为<code>1</code>，并且往往是左子树深度更高。一棵满二叉树可以是完全二叉树，但一棵完全二叉树不一定是满二叉树，也就是说它不一定是左右对称的。</p>
</li>
</ul>
<p>二叉树平均来说深度比$N$小很多，它的平均深度为$O(\sqrt N)$。而对于二叉查找树来说，深度的平均值为$O(\log N)$。记住，这些深度仅仅是平均深度，存在一些坏东西会让深度达到$N-1$，比如上面提到的斜树，它是一种最坏情况。顺手一提，二叉树本质上就是图。</p>
<ul>
<li><h5 id="二叉树的应用"><a href="#二叉树的应用" class="headerlink" title="二叉树的应用"></a>二叉树的应用</h5><ul>
<li><p>表达式树(expression tree)</p>
<p>在一棵表达式树中，树叶是操作数(operand)，是常数或者变量；而其他的节点都是操作符(operator)。我们可以通过表达式树来描述一道表达式。</p>
</li>
<li><p>二叉查找树(binary search tree)</p>
<p>二叉查找树与原始二叉树的最大区别在于它为左右子树添加了优先级，对于一个节点来说，它的左子树中的所有关键字必定小于它，它的右子树中的所有关键字必定大于它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># BST的声明</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">SearchTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">AvlTree <span class="title">MakeEmpty</span><span class="params">(AvlTree T)</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">Find</span><span class="params">(ElementType X, AvlTree T)</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">FindMin</span><span class="params">(AvlTree T)</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">FindMax</span><span class="params">(AvlTree T)</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">Insert</span><span class="params">(ElementType X, AvlTree T)</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">Delete</span><span class="params">(ElementType X, AvlTree T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    SearchTree Left;</span><br><span class="line">    SearchTree Right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>MakeEmpty</code>初始化树。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SearchTree <span class="title">MakeEmpty</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           MakeEmpty(T-&gt;Left);</span><br><span class="line">           MakeEmpty(T-&gt;Right);</span><br><span class="line">           <span class="built_in">free</span>(T);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Find</code>查找并返回指定关键字的指针</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X, SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(X &lt; T-&gt;Element)</span><br><span class="line">        <span class="keyword">return</span> Find(X,T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; T-&gt;Element)</span><br><span class="line">        <span class="keyword">return</span> Find(X,T-&gt;Right);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>FindMin</code>查找并返回最小关键字的指针</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;Left == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMin(T-&gt;Left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>FindMax</code>查找并返回最大关键字的指针</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;Right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMax(T-&gt;Right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> <code>Insert</code>插入元素</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SearchTree <span class="title">Insert</span><span class="params">(ElementType X, SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T = (SearchTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Out of space!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;Element = X;</span><br><span class="line">            T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;Element)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;Left= Insert(X, T-&gt;Left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; T-&gt;Element)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;Right= Insert(X, T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Delete</code>删除元素</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SearchTree <span class="title">Delete</span><span class="params">(ElementType X, SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position tmpCell;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error! No such element\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( X &lt; T-&gt;Element)</span><br><span class="line">        T-&gt;Left = Delete(X, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( X &gt; T-&gt;Element)</span><br><span class="line">        T-&gt;Right = Delete(X, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( T-&gt;Left &amp;&amp; T-&gt;Right)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpCell = FindMin(T-&gt;Right);</span><br><span class="line">        T-&gt;Element = tmpCell-&gt;Element;</span><br><span class="line">        T-&gt;Right = Delete(T-&gt;Element, T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">            tmpCell = T;</span><br><span class="line">            <span class="keyword">if</span>(T-&gt;Left == <span class="literal">NULL</span>)</span><br><span class="line">                T = T-&gt;Right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;Right == <span class="literal">NULL</span>)</span><br><span class="line">                T = T-&gt;Left;</span><br><span class="line">            <span class="built_in">free</span>(tmpCell);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，该例程效率并不高，它沿着树进行了两遍搜索。原书推荐写一个特殊的<code>DeleteMin</code>以提升效率。</p>
<ul>
<li><p>懒惰删除(lazy deletion)</p>
<p>当删除的次数不多的时候，我们可以考虑懒惰删除的处理方案。懒惰删除和真正的删除相比，只是将要删除的节点标记为已删除/不存在，并没有切实地将其从树中移除。这需要在每个节点加上一个是否被删除的记号。懒惰删除对于重复关键字的情形，能减少开销，只需要改变记号便能切换删除状态。</p>
</li>
</ul>
</li>
<li><p>AVL(Adelson-Velskii和Landis)树</p>
<p>我们前面提到的平均深度只是一个平均的情况，在实际应用中原始的二叉树经过大量的Insert/Delete会出现一些性能上的问题。为了保证性能，我们需要对二叉树的结构进行<code>平衡(balance)</code>操作，这是一个典型的方案，而AVL树便是最老的一种平衡查找树。</p>
<p>在一棵AVL树中，左子树和右子树的高度最多差<code>1</code>，而一棵空树的高度为<code>-1</code>。</p>
<p>假设我们以及拥有了一棵AVL树，然后对其进行插入操作，但是我们在插入一个节点后可能会破坏AVL树的平衡特性，即左右子树高度差超出<code>1</code>。为了保证AVL树的存在，我们必须对插入进行修正，让它在插入后仍然保持平衡。这种操作称为旋转(rotation)。</p>
<p>旋转是AVL树中一个较为重要的概念。为了更容易理解我们可以遵循以下几条规则：</p>
<ol>
<li><p>旋转是发生在两个节点之间的。</p>
</li>
<li><p>旋转没有改变每个节点的关键值，仅仅改变了位置关系。</p>
</li>
<li><p>旋转往往从根节点出发。</p>
<p>假设需要重新平衡的节点叫做α。在高度不平衡时，左右子树高度差2。</p>
<p>| 简称 | 详情                          | 对应旋转         |<br>| —— | ——————————————- | ———————— |<br>| LL   | 对α左儿子的左子树进行一次插入 | 右单旋转         |<br>| LR   | 对α左儿子的右子树进行一次插入 | 先左旋转再右旋转 |<br>| RL   | 对α右儿子的左子树进行一次插入 | 先右旋转再左旋转 |<br>| RR   | 对α右儿子的右子树进行一次插入 | 左单旋转         |</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>  - 单旋转

    - 左旋转SingleRotateWithLeft

      当我们发现树向右边倾斜时，即右子树的高度高于左子树高度（一般是相差为2）时，我们将进行左旋转以将树重新平衡为完全二叉树。

      <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  这个和下面的右旋转方法都只能在K2有左子树或右子树的情况下使用，</span></span><br><span class="line"><span class="comment">  它将K2和它的左子树旋转换位，</span></span><br><span class="line"><span class="comment">  然后更新了高并返回新的根节点</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> Position <span class="title">SingleRotateWithLeft</span><span class="params">(Position K2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      Position K1;</span><br><span class="line">      </span><br><span class="line">      K1=K2-&gt;Left;</span><br><span class="line">      K2-&gt;Left=K1-&gt;Right;<span class="comment">//K2-&gt;Left=K2-&gt;Left-&gt;Right</span></span><br><span class="line">      K1-&gt;Right=K2;</span><br><span class="line">  </span><br><span class="line">    K2-&gt;height = Max(Height(K2-&gt;Left), Height(K2-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">      K1-&gt;height = Max(Height(K1-&gt;Left), Height(K2)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> K1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    - 右旋转SingleRotateWithRight

      当我们发现树向左边倾斜时，即左子树的高度高于右子树高度（一般是相差为2）时，我们将进行右旋转以将树重新平衡为完全二叉树。

      <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">SingleRotateWithLeft</span><span class="params">(Position K2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position K1;</span><br><span class="line">    </span><br><span class="line">    K1=K2-&gt;Right;</span><br><span class="line">    K2-&gt;Right=K1-&gt;Left;</span><br><span class="line">    K1-&gt;Left=K2;</span><br><span class="line"></span><br><span class="line">  K2-&gt;height = Max(Height(K2-&gt;Right), Height(K2-&gt;Left)) + <span class="number">1</span>;</span><br><span class="line">    K1-&gt;height = Max(Height(K1-&gt;Right), Height(K2)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> K1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  - 双旋转

    - LR左右旋DoubleRotateWithLeft

      <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> AvlTree <span class="title">DoubleRotateWithLeft</span><span class="params">(Position K3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    K3-&gt;Left = SingleRotateWithLeft(K3-&gt;Left);</span><br><span class="line">    <span class="keyword">return</span> SingleRotateWithRight(K3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    - RL右左旋DoubleRotateWithRight

      <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> AvlTree <span class="title">DoubleRotateWithRight</span><span class="params">(Position K3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    K3-&gt;Left = SingleRotateWithRight(K3-&gt;Right);</span><br><span class="line">    <span class="keyword">return</span> SingleRotateWithLeft(K3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- 伸展树(splay tree)

  伸展树保证从空树开始连续M次对树的操作最多花费$O(M\log N)$时间。在伸展树中我们每次访问一个特定的节点，都会将这个节点通过旋转变换为树根。这样做会使得一些经常被访问的节点会聚集在根附近，从而提升访问效率。原书在这里使用了摊还分析(amortized analysis)方法，$\log N$为伸展树每次操作的摊还代价。

  相比AVL树，伸展树的编程实现要简单的多，不需要过多考虑许多情况和存储平衡信息（AVL树中的height）。在12章中我们会见到一中实战更好的伸展树变体。
</code></pre><ul>
<li><p>B树(B-tree)</p>
<p>B树不是二叉树！</p>
<p>相比二叉树来说，<strong>B树所有树叶都在相同深度上</strong>，这与满二叉树有相似之处。</p>
<p>而<strong>它的根要么是一片树叶（原文可能更强调它没有子节点），要么它的子节点数量在$2和M$之间</strong>。<strong>而除根外的所有非树叶节点的子节点数量在$\frac{M}{2}和M$之间。</strong></p>
<blockquote>
<p>B树所有数据都存储在树叶上。</p>
</blockquote>
<p>我们将3阶B树称为2-3树。而4阶被称为2-3-4树。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构和算法分析 C语言描述》笔记#5 散列</title>
    <url>/reports/ab388864bf55/</url>
    <content><![CDATA[<blockquote>
<h4 id="散列-Hash"><a href="#散列-Hash" class="headerlink" title="散列(Hash)"></a>散列(Hash)</h4></blockquote>
<ul>
<li><blockquote>
<p>什么是散列？</p>
</blockquote>
<p>将一段输入通过某种方式计算得到一个尽可能独一无二的输出的过程就叫做<code>散列</code>。一般来说，这个过程对于不同的输入，得到的输出应该是具有相同长度，而输出的长度往往小于输入，并且输出应该尽可能不同。我们将这个<code>输入</code>叫做关键字，输出叫做<code>散列值</code>。这个计算过程使用的函数叫做<code>散列函数</code>，它将不同的关键字映射为不同的散列值。</p>
</li>
<li><blockquote>
<p>散列函数</p>
</blockquote>
<p>为了更方便的理解散列，我们这里引入散列表的概念。这个表是一个有限的数组，我们可以通过散列函数得到每个关键字的散列值作为它们的下标，这样就可以把关键字存储在数组中。为了尽可能的提升效率和利用率，我们必须保证这个数组被填满并且没有错误。一般来讲，一个理想的散列函数会均匀的分配关键字从而保证关键字被映射到不同的单元。倘若两个关键字得到同一个散列值，这就发生了<code>Hash碰撞/冲突(collision)</code>。</p>
</li>
<li><blockquote>
<p>碰撞的解决</p>
</blockquote>
<ul>
<li><p>分离链接法(separate chaining)</p>
<p>当关键字们得到同一个散列值时，我们将这些关键字串起来，单独放在一个（链）表中。这样散列表中原本放置一个关键字的地方，放置了一个装有许多关键字的链表。为了方便起见，我们可以在空间足够的情况下为链表加入一个表头，这纯属个人喜好。你甚至可以不使用链表，而使用别的数据结构。</p>
</li>
<li><p>开放定址法(open addressing hashing)</p>
<p>开放定址法和分离链接法思想不同，开放定址法在遇到冲突情况时，会为关键字寻找另外可用的单元，而不是将同一散列值的关键字聚集在一起。</p>
<ul>
<li><p>线性探测法</p>
<p>在这个方法中，函数$F$是一个线性的函数，也就是说为了找到一个可用的空单元，会逐个探测访问每个单元。在若干次插入后，有关键字的单元会连续的靠在一起，这被称为一次聚集(primary clustering)。我们可以简单的料到，只要表中空单元越多，在进行插入时访问的单元数量就会越少，消耗就越少。反而言之，只要表中大多数单元已经被填满，就不要使用这个方法，它会探测过多单元从而花费过多资源。</p>
</li>
<li><p>平方探测法</p>
<p>平方探测法消除了线性探测法中的一次聚集问题。在平方探测法中，冲突函数是二次函数，如$F(i)=i^2$。在平方探测法中，存在一个定理：</p>
<blockquote>
<p>“当表至少有一半是空的，并且表的大小为素数时，总能够插入一个新的元素。”</p>
</blockquote>
<p>但是，当表填满过半或表的大小不是素数时，可能平方探测法的表现不尽人意。为了更好的使用这个方法，我们可以将散列表的大小设置为总元素个数的两倍大小。虽然消除了一次聚集，但平方探测法也带来了二次聚集(secondary clustering)问题。</p>
</li>
<li><p>双散列(double hashing)</p>
<p>顾名思义，使用了两个散列函数。我们将第二个散列函数称为$hash_2(X)$。而冲突函数一个例子为$F(i)=i·hash_2(X)$。我们应该尽可能使得$hash_2(X)$的结果不为$0$值，如$hash_2(X)=R-(X\mod R)$，其中$R$为小于散列表大小的素数。</p>
</li>
</ul>
</li>
<li><p>再散列</p>
<p>再散列会建立一个大小为原散列表的两倍的新散列表，并把原表中每个元素通过新的散列函数插入新表中。</p>
</li>
<li><p>可扩散列(extendible hashing)</p>
<p>可扩散列的目的是处理数据量过大以至装不进主存的情况。可扩散列通过使用位的根与树叶来将数据分开，我们用$D$代表根使用的位数，或称目录(directory)。也就是说，根中有$2^D$种情况。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构和算法分析 C语言描述》笔记#6  堆</title>
    <url>/reports/8a884bafbfc4/</url>
    <content><![CDATA[<blockquote>
<h4 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h4></blockquote>
<ul>
<li><p>二叉堆(binary heap)</p>
<p>一般我们不加修饰地使用堆这个词时，一般指的都是二叉堆。堆具有两个性质：结构性和堆序性。</p>
<ul>
<li><p>结构性</p>
<p>堆是一棵完全二叉树。因为它是一棵完全二叉树，具有一定规律，所以我们可以简单的使用简单数组实现它。</p>
</li>
<li><p>堆序性</p>
<p>对于每个节点来说，它的父节点的关键字都应该比这个节点小（根节点除外，它没有父节点）。</p>
</li>
</ul>
<p>在介绍完了堆的两个性质后，我们便可以着手对其进行操作，值得一提的所有操作都必须满足这两个性质！</p>
<ul>
<li><p><code>Insert</code>插入</p>
<p>在插入时我们有一个常见的策略，叫做<code>上滤(percolate up)</code>。这个策略指的是我们的插入操作将从树叶开始不断往上寻找一个可能的位置。这个位置将在完成插入的同时，保证了二叉堆的两个性质。当我们要插入的关键字是新的最小值时，这个过程会持续到上滤到根节点为止。</p>
</li>
<li><p><code>DeleteMin</code>删除最小元</p>
<p> 当我们删除一个最小元时，根节点位置处会出现一个空穴。为了填补这个空穴，我们必须将子节点上移，这相当于把空穴不断下移，这个过程叫做<code>下滤(percolate down)</code>。</p>
</li>
<li><p><code>DecreaseKey</code>降低关键字的值</p>
<p>降低指定位置关键字的值，如果破坏了堆的序，则需要通过上滤进行调整。</p>
</li>
<li><p><code>IncreaseKey</code>提升关键字的值</p>
<p>提升指定位置关键字的值，如果破坏了堆的序，则需要通过下滤进行调整。</p>
</li>
<li><p><code>Delete</code>删除</p>
<p>先通过<code>DecreaseKey</code>将指定节点上滤，再通过<code>DeleteMin</code>删除节点。</p>
</li>
<li><p><code>BuildHeap</code>构建堆</p>
<p>通过N个关键字构建一个堆。</p>
</li>
</ul>
</li>
<li><p>d-堆</p>
<p>d-堆恰似二叉堆，只不过每个节点至多可以有d个子节点。</p>
</li>
<li><p>左式堆(leftist heap)</p>
<p>左式堆是二叉树，也具有和二叉树相同的结构性和堆序性，唯一的不同在于左式堆不是理想平衡的，或者说实际上趋于非常不平衡。</p>
<ul>
<li><p>零路径长(Null Path Length, NPL)</p>
<p>零路径长为一个节点到一个没有两个子节点的节点的最短路径长。具有0或1个子节点的节点的NPL为0（因为它们自己到自己的距离为0），而NPL(Null)为-1。</p>
</li>
</ul>
<p>而对于左式堆来说，堆中的每一个节点X,左子节点的NPL大于等于右子节点的NPL。左式堆的这个性质将驱使左路径加深，右路径会变为堆中的最短路径。这将有利于合并操作。</p>
</li>
<li><p>斜堆(skew heap)/自适应堆(self-adjusting heap)</p>
<p>斜堆是左式堆的自调节形式。它没有NPL的概念。</p>
</li>
<li><p>二项队列(binomial queue)</p>
<p>二项队列和前面提到的优先队列不同，它的结构与其说像树，不如说更像是伞形结构。一棵二项树$B<em>k$可以看作是$B_0$到$B</em>{k-1}$的根作为同一个节点的子节点的产物。这样一来，每个二项树的节点数为$2^k$，这个结构规律性十分明显。</p>
<p>这样一来我们可以用这些二项树的集合表示任意大小的优先队列。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构和算法分析 C语言描述》笔记#7 排序算法</title>
    <url>/reports/eb9331feb36c/</url>
    <content><![CDATA[<blockquote>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4></blockquote>
<p>这一章将围绕着数组元素的排序展开。为了减轻负担，所有的元素都为整数（其实前面几章也都是这样做的）。</p>
<ul>
<li><p>内部排序和外部排序</p>
<ul>
<li>内部排序：整个排序工作可以在主存中完成，元素个数一般小于$10^{6}$。</li>
<li>外部排序：整个排序工作不能再主存中完成而必须在磁带或磁盘中完成。</li>
</ul>
</li>
</ul>
<p>另外，为了后面的叙述方面，我们假定这个数列的长度为$N$。</p>
<blockquote>
<h6 id="插入排序InsertionSort"><a href="#插入排序InsertionSort" class="headerlink" title="插入排序InsertionSort"></a>插入排序InsertionSort</h6></blockquote>
<p>插入排序的原理很简单。首先我们给出一个位置$P$，假设在位置$P$之前的数列都已经处于已排序状态，这样位置$P$处的元素只需要在前面的数列找到自己合适的的位置即可。总的来说，我们要跑$N-1$次，位置$0$上的元素不需要排序，因为对于一个元素的数列来说，有序无序没有意义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">书上给的样例，因为P前的元素都已经排序，那么我们只需要保证有足够的位置让P处的元素插入即可。</span></span><br><span class="line"><span class="comment">这样一来，我们仅仅目标位置右边到P位置的元素向右移动一个位置便能够得到足够的位置供P处元素插入。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, P;</span><br><span class="line">    </span><br><span class="line">    ElementType tmp;</span><br><span class="line">    <span class="keyword">for</span>(P=<span class="number">1</span>;P&lt;N;P++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=A[P];</span><br><span class="line">        <span class="keyword">for</span>(j=P;j&gt;<span class="number">0</span> &amp;&amp; A[j<span class="number">-1</span>]&gt;tmp;j--)</span><br><span class="line">            A[j]=A[j<span class="number">-1</span>];</span><br><span class="line">        A[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h6 id="一些简单排序算法的下界"><a href="#一些简单排序算法的下界" class="headerlink" title="一些简单排序算法的下界"></a>一些简单排序算法的下界</h6></blockquote>
<ul>
<li><p>逆序(inversion)</p>
<p>数组中具有$i<j$但是$A[i]>A[j]$的序偶<sup><a href="#fn_1" id="reffn_1">1</a></sup> ($A[i],A[j]$)。一个排过序（升序）的数组没有逆序。</p>
<p>我们假设不存在重复元素，并且所有的排列都是有可能的。可以得到下列两个定理：</p>
<ol>
<li><p>$N$个互异数的数组的平均逆序数是$N(N-1)/4$。</p>
<p><a href="http://mathonline.wikidot.com/inversions-of-permutations">证明可见</a></p>
</li>
<li><p>通过交换相邻元素进行排序的任何算法平均都需要$\Omega (N^2)$时间。</p>
<p>这个定理建立在前一个定理的基础上，我们交换的次数实际上就是逆序的个数。</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<h6 id="希尔排序ShellSort"><a href="#希尔排序ShellSort" class="headerlink" title="希尔排序ShellSort"></a>希尔排序ShellSort</h6></blockquote>
<p>希尔排序名字源于它的发明者Donald Shell。它是冲破二次时间屏障的第一批算法之一，拥有亚二次时间界。由于它的工作原理，又被称为缩小增量排序(diminishing increment sort)。</p>
<p>在希尔排序中，我们取一系列的数值作为增量(increment)，这一系列数值被称作增量序列(increment sequence)。增量序列由$h_1$开始逐步增大（这不一定是一个递增数列），也就是这样的序列：$h_1,h_2…h_t$。其中$h_1$等于1，在实际排序过程中，增量是由大到小最后到1的。</p>
<p>希尔排序是插入排序的更好版本，在这个排序过程中，我们将数组元素分为$h<em>t$个小组，然后各个小组内进行插入排序；接着增量$h_t$减少为$h</em>{t-1}$，重复前面的操作。在这个过程中，数组的有序性不断提高，最后我们就能够得到一个排序好的数组。</p>
<p><img data-src="E:\Docus\C\《数据结构和算法分析 C语言描述》笔记\images\7\7.4_shellsort_increment5.png" alt="shellsort" style="zoom:50%;" /></p>
<p>如图，希尔排序的一次排序中，进行了多次插入排序。</p>
<h5 id="关于增量序列的选择"><a href="#关于增量序列的选择" class="headerlink" title="关于增量序列的选择"></a>关于增量序列的选择</h5><p>Shell建议的序列为：$h<em>t = N/2, h_k=h</em>{k+1}/2$。这个序列很流行，但是并不好。在实际上，我们应该尽量减少增量间的公因子，最好的情况是增量互素。</p>
<blockquote>
<h5 id="堆排序heapSort"><a href="#堆排序heapSort" class="headerlink" title="堆排序heapSort"></a>堆排序heapSort</h5></blockquote>
<p>堆排序是建立在我们前几章提到的优先队列的基础上的，它利用了二叉堆的结构性和堆序性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LeftChild(i) (2*(i)+1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">percDown</span><span class="params">(elementType A[], <span class="keyword">int</span> i, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    elementType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (tmp = A[i];LeftChild(i) &lt; N; i = child)</span><br><span class="line">    &#123;</span><br><span class="line">        child = LeftChild(i);</span><br><span class="line">        <span class="keyword">if</span>( child != N - <span class="number">1</span> &amp;&amp; A[child + <span class="number">1</span>] &gt; A[child])</span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span> ( tmp &lt; A[child])</span><br><span class="line">            A[i] = A[child];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    A[i] = tmp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(elementType A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = N/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//构建堆</span></span><br><span class="line">        percDown(A, i , N);</span><br><span class="line">    <span class="keyword">for</span> (i = N<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--)<span class="comment">//删除最大值，但实际上并没有移除</span></span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;A[<span class="number">0</span>], &amp;A[i]);</span><br><span class="line">        percDown(A, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h5 id="归并排序mergeSort"><a href="#归并排序mergeSort" class="headerlink" title="归并排序mergeSort"></a>归并排序mergeSort</h5></blockquote>
<p>归并排序将两个已排序的合并到第三个表中。这涉及到三个数组和三个计数器（指针），前两个数组为长度相同的输入数组，后一个数组为输出数组。指向两个输入数组的指针指向的元素下标相同，选中相同下标的两个元素中较小的那个填入输出数组。</p>
<p>实际应用中，我们将一个数组分为前后两个输入数组进行归并排序（分治思想），见以下例程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(elementType A[], elementType tmpArray[], <span class="keyword">int</span> lPos, <span class="keyword">int</span> rPos, <span class="keyword">int</span> rightEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,leftEnd,numElements,tmpPos;</span><br><span class="line"></span><br><span class="line">    leftEnd = rPos<span class="number">-1</span>;</span><br><span class="line">    tmpPos = lPos;</span><br><span class="line">    numElements = rightEnd - lPos + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(lPos &lt;= leftEnd &amp;&amp; rPos &lt;= rightEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[lPos] &lt;= A[rPos])</span><br><span class="line">            tmpArray[tmpPos++] = A[lPos++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmpArray[tmpPos++] = A[rPos++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lPos &lt;= leftEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpArray[tmpPos++] = A[lPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (rPos &lt;= rightEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpArray[tmpPos++] = A[rPos++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numElements; i++, rightEnd--)</span><br><span class="line">    &#123;</span><br><span class="line">        A[rightEnd] = tmpArray[rightEnd];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mSort</span><span class="params">(elementType A[], elementType tmpArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> center;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        center = (left + right)/<span class="number">2</span>;</span><br><span class="line">        mSort(A, tmpArray, left, center);</span><br><span class="line">        mSort(A, tmpArray, center + <span class="number">1</span>, right);</span><br><span class="line">        Merge(A, tmpArray, left, center + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(elementType A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    elementType *tmpArray;</span><br><span class="line"></span><br><span class="line">    tmpArray = <span class="built_in">malloc</span>(N*<span class="keyword">sizeof</span>(elementType));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tmpArray != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mSort(A, tmpArray, <span class="number">0</span>, N<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">free</span>(tmpArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fatalError(<span class="string">&quot;No space available for tmpArray&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h5 id="快速排序quickSort"><a href="#快速排序quickSort" class="headerlink" title="快速排序quickSort"></a>快速排序quickSort</h5></blockquote>
<p>快速排序是实践中已知的最快的排序算法，它是一种采用分治思想的递归算法。但值得一提的是，对于小数组的处理，快速排序并不是最好的选择，插入排序会更好。</p>
<blockquote>
<p>快速排序可以简单地分为四个步骤：</p>
<ol>
<li>如果S中元素个数是0或1，返回。</li>
<li>取S中任意一个元素$v$，作为<code>枢纽元(pivot)</code>。</li>
<li>将S中剩下的元素分为两个不相交的集合$S_1={x\in S | x\leq v }和S_2={x\in S | x\geq v }$。</li>
<li>返回quickSort($S_1$)，继而$v$，然后quickSort($S_2$)。</li>
</ol>
</blockquote>
<h6 id="枢纽元的选取"><a href="#枢纽元的选取" class="headerlink" title="枢纽元的选取"></a>枢纽元的选取</h6><p>我们的输入很有可能是预排序的，为了保证$S_1,S_2$大小尽量相等，我们不要选择第一或者第二个元素作为枢纽元，这可能会让两边严重不平衡。</p>
<p>随机选取枢纽元是一个不错的想法，这个办法有一定的安全性，毕竟随机的枢纽元不会接连不断地产生劣质的分割。</p>
<p>还有一个更好的选择，<code>三数中值分割法(Median-of-Three Partitioning)</code></p>
<p>我们首先选取第最左边的元素，中间位置的元素，和最右边的元素，对它们进行排序，选择中值作为枢纽元。这种方案不仅能一定消除坏情况，还能减少快排的运行时间。</p>
<h6 id="如何分割"><a href="#如何分割" class="headerlink" title="如何分割"></a>如何分割</h6><p>分割的策略选择是一个问题。原书使用了两个下标$i,j$，$i$从数组的第一个开始往后移动，$j$从数组的最后一个向前移动。在移动的过程中，当$i$移动到大于枢纽元的元素就停下，当$j$移动到小于枢纽元的元素就停下，这样一来，当$i,j$都停下时，$i$指向一个大元素，$j$指向一个小元素，这个时候如果$i$还在$j$的左边，那么交换两者指向的元素。</p>
<p>我们不断重复这个过程，直到$i,j$指向同一个元素。</p>
<p>然后我们进行分割的最后一步，将枢纽元与$i$指向的元素交换位置。</p>
<p>这样一来我们便能保证枢纽元左边的元素都比它小，右边的元素比它大。</p>
<p>现在我们该开始考虑如何处理那些等于枢纽元的关键字。书上的建议是当遇到这种情况时，我们应该停下$i,j$，直接进入下一个步骤。</p>
<h6 id="不要用快速排序对小数组排序"><a href="#不要用快速排序对小数组排序" class="headerlink" title="不要用快速排序对小数组排序"></a>不要用快速排序对小数组排序</h6><p>当数组的长度$N\leq 20$时，选择插入排序会比快速排序更好。</p>
<h6 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> elementType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cuttoff ( 3 )</span></span><br><span class="line"></span><br><span class="line"><span class="function">elementType <span class="title">median3</span><span class="params">(elementType A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> center = (left + right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (A[left] &gt; A[center])</span><br><span class="line">        swap(&amp;A[left], &amp;A[center]);</span><br><span class="line">    <span class="keyword">if</span> (A[left] &gt; A[right])</span><br><span class="line">        swap(&amp;A[left], &amp;A[right]);</span><br><span class="line">    <span class="keyword">if</span> (A[center] &gt; A[right])</span><br><span class="line">        swap(&amp;A[center], &amp;A[right]);</span><br><span class="line"></span><br><span class="line">    swap(&amp;A[center], &amp;A[right<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> A[right<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qSort</span><span class="params">(elementType A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    elementType pivot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left + Cuttoff &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        pivot = median3(A, left, right);</span><br><span class="line">        i = left;</span><br><span class="line">        j = right - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( A[++i] &lt; pivot)&#123;&#125;;</span><br><span class="line">            <span class="keyword">while</span>( A[--j] &lt; pivot)&#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                swap(&amp;A[i], &amp;A[j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;A[i], &amp;A[right - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        qSort(A, left, i - <span class="number">1</span>);</span><br><span class="line">        qSort(A, i + <span class="number">1</span>, right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        insertionSort(A + left, right - left + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(elementType A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qSort(A, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="快速选择quickSelect"><a href="#快速选择quickSelect" class="headerlink" title="快速选择quickSelect"></a>快速选择quickSelect</h6><p>我们可以把快排的思想应用到解决选择问题上，即查找第$k$个最小/大元。这只需要简单的将两次递归减少为一次递归（因为前文提到的分割策略）。如果你希望这个过程不破坏原来的排序，只需要在拷贝上进行这个操作。</p>
<blockquote>
<h5 id="针对大型结构"><a href="#针对大型结构" class="headerlink" title="针对大型结构"></a>针对大型结构</h5></blockquote>
<p>非基本类型，如结构体等等，我们可以通过比较它们某个特定的域来排序。但不需要交换他们的位置，只需要交换指向这些结构的指针即可。</p>
<blockquote>
<h5 id="决策树decision-tree"><a href="#决策树decision-tree" class="headerlink" title="决策树decision tree"></a>决策树decision tree</h5></blockquote>
<p><img data-src="E:\Docus\C\《数据结构和算法分析 C语言描述》笔记\images\7\7.9_decisionTree.png" alt="7.9_decisionTree" style="zoom:67%;" /></p>
<p>如图，这是一棵决策树。决策树用来证明下界，是一个抽象概念。作为一棵二叉树，它具备二叉树的基本性质：</p>
<blockquote>
<ol>
<li>若决策树深度为$d$，则最多有$2^d$片树叶。</li>
<li>具有$L$片树叶的二叉树的深度至少是$\log L$。</li>
</ol>
</blockquote>
<p>另附书上的两个定理</p>
<blockquote>
<ol>
<li>只使用元素间比较的任何排序算法在最坏情况下至少需要$\log(N!)$次比较。</li>
<li>只使用元素间比较的任何排序算法需要进行$\Omega (N\log N)$次比较。</li>
</ol>
<h5 id="桶式排序bucketsort"><a href="#桶式排序bucketsort" class="headerlink" title="桶式排序bucketsort"></a>桶式排序bucketsort</h5></blockquote>
<p>我们假设所有的输入数据都为正整数，且小于$M$。建立一个长度为$M$的数组，来记录输入数据中每个相同数字的个数。也就是说这个数组每个单元都存储着某个数字的个数信息，在输入数组的过程中我们就已经完成了排序。</p>
<blockquote>
<h5 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h5></blockquote>
<p>有些时候，输入数据量过大以至于装不进内存，这种时候就需要外部排序登场。</p>
<h6 id="多路合并"><a href="#多路合并" class="headerlink" title="多路合并"></a>多路合并</h6><p>首先我们引入<code>顺串run</code>的概念。顺串是是一串排序好的序列。</p>
<p>在多路合并中，我们将读取的输入数据分为机组存储在多个存储介质中，并分别选择排序，这些存储介质中的便是顺串。值得一提的是，顺串没有长度的规定，可长可短。紧接着我们将这些不同存储介质中的顺串合并到其他可用介质中，如此反复，便可以得到完全排序好的顺串。</p>
<h6 id="多相合并"><a href="#多相合并" class="headerlink" title="多相合并"></a>多相合并</h6><p>多相合并的思路和多路合并相同，不过使用的介质数量少于多路合并。在多路合并中，我们的$k-$路合并方法往往需要$2k$个存储介质。而多相合并将顺串不均衡地分成两部分，这个过程顺串的数量变化遵循斐波那契数列。</p>
<h6 id="替换选择replacement-selection"><a href="#替换选择replacement-selection" class="headerlink" title="替换选择replacement selection"></a>替换选择replacement selection</h6><p>我们假设一次从文件读入多条记录（可能是整数），用它们构建一个优先队列，一般是堆。然后弹出最小值，将这个最小值写出。接着再从文件中读取一条记录，如果它比上一个弹出的最小值小，我们不能把它加入到当前的这个优先队列中（为了保证写出的记录是升序，由小到大排序），便把它放入优先队列的死区（dead space）。如果比上一个弹出的最小值大，那就把它加入到当前的优先队列中，并调整优先队列以保证堆序性。</p>
<p>重复这个过程，直到优先队列大小为零。这时候，顺串的构建已经完成了，我们使用优先队列死区中的元素再构建一个新的优先队列来构建新的顺串。</p>
<p>如此重复直到顺串长度为1。</p>
<p>最后的步骤便是将所有顺串合并。</p>
<p><a href="http://web.eecs.utk.edu/~leparker/Courses/CS302-Fall06/Notes/replacement_selection.html">更详细的说明可见此</a>。</p>
<blockquote id="fn_1">
<sup>1</sup>. 序偶： ordered pair，用<code>()</code>包裹的一对数字，如<code>(3,6)</code>，出自离散数学。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构和算法分析 C语言描述》笔记#8 不相交集ADT</title>
    <url>/reports/e34a4d024b13/</url>
    <content><![CDATA[<blockquote>
<h5 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h5></blockquote>
<p>首先我们需要明确关系的定义:</p>
<p>我们假设存在两个元素$a,b(a,b\in S)$，两个元素之间可能存在某种关系，或者不存在某种关系。倘若它们有关系，则$aRb$为$true$，否则为$false$。这里R全称为Relation，为关系的英文单词。</p>
<p>在这个基础上，我们提出<strong>等价关系(equivalence relation)</strong>，它满足下列条件：</p>
<ol>
<li>自反性：对于所有的$a\in S$，$aRa$。</li>
<li>对称性：$aRb$当且仅当$bRa$。</li>
<li>传递性：$aRb,bRc$，则$aRc$。</li>
</ol>
<p>只有满足这三个条件的关系才能够被称作等价关系。一般来说，带有方向性的关系都不是等价关系，如箭头两边的端点，虽然可传递可自反，但却不满足对称，除非是双向箭头。</p>
<hr>
<blockquote>
<h5 id="动态等价性"><a href="#动态等价性" class="headerlink" title="动态等价性"></a>动态等价性</h5></blockquote>
<p>我们现在接着提出<strong>等价类(equivalence class)</strong>的概念。一个元素$a\in S$的等价类是$S$的子集，包含所有和$a$等价的元素。假如$a和b$等价，那么它们必然处于同一个等价类中。假如$S$中的每个元素都不互相等价，那么每一个元素只有一个等价类，这个等价类内的元素只有他们自己。</p>
<p>输入数据是$N$个集合的类(collection)，每个集合只有一个元素，$S_1 \cap S_2 =\empty$。这些集合不相交(disjoint)。</p>
<p>在这种情况下我们有两种运算：</p>
<ol>
<li><strong>Find</strong>：返回包含给定元素的集合的名字。用来比较两个元素是否处于同一个类中。</li>
<li><strong>Union</strong>：把含有两个元素的两个等价类合并成一个等价类。</li>
</ol>
<p>这两种运算的算法是<strong>动态的(dynamic)</strong>，Union操作会改变集合。</p>
<p>为了解决动态等价性问题，实现这个算法我们有两个选择：</p>
<ol>
<li>保证<strong>Find</strong>能够以常数最坏情形运行时间执行。</li>
<li>保证<strong>Union</strong>能够以常数最坏情形运行时间执行。</li>
</ol>
<p>这两个选择是无法共存的，我们只能选择其一。</p>
<h6 id="Find的实现思路："><a href="#Find的实现思路：" class="headerlink" title="Find的实现思路："></a>Find的实现思路：</h6><ol>
<li>数组实现： 使用一个数组保存每个元素的等价类的名字，如果我们有$N$个元素，那么数组长度就为$N$。在这个实现上，如果我们想要Union，那么就要扫描整个数组，修改指定元素指向的等价类。</li>
<li>链表实现：每个等价类都用一个链表实现，每个链表内的元素都满足等价关系。相对于数组实现来说，这会节省更新的时间，但却不能单独减少渐进运行时间。</li>
</ol>
<hr>
<blockquote>
<h5 id="灵巧求并算法"><a href="#灵巧求并算法" class="headerlink" title="灵巧求并算法"></a>灵巧求并算法</h5></blockquote>
<ol>
<li><p>一种可能的默认实现：</p>
<p>我们采纳一个约定：<code>Union(X,Y)</code>后，新的根是$X$。</p>
</li>
<li><p>灵巧求并算法</p>
<ol>
<li><p>按大小求并(union-by-size)：</p>
<p>我们将树的大小存储在根节点，并且因为所有节点元素值都是正整数，我们可以尽情为大小加上负号，这避免了一些不必要的冲突。非子节点会存储它指向的下一个节点的名称（指针）。</p>
<p>我们设一开始，每个等价类只有一个元素的时候，树的大小为-1。每次合并，小树（树的大小相比之下更小）作为子树来合并到另一棵树的根节点下。每次合并得到的新树的大小为原本两棵树的和。</p>
</li>
<li><p>按高度/秩求并(union-by-height)：</p>
<p>按高度求并和按大小求并看起来十分相似。不过一开始时，每棵树的高度为0。并且合并后只有原来两棵树高度相同时，树的高度才加1（当然，因为负号的关系，实际上是减去1）。非根节点指向下一个节点。</p>
</li>
</ol>
</li>
</ol>
<hr>
<blockquote>
<h5 id="路径压缩path-compression"><a href="#路径压缩path-compression" class="headerlink" title="路径压缩path compression"></a>路径压缩path compression</h5></blockquote>
<p>路径压缩的目的是加速算法，让Find操作更便捷。</p>
<p>使用了路径压缩的算法会复制一份数组的副本，并且将从根节点到目标节点的所有节点（包括目标节点）都指向根节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">setType <span class="title">Find</span><span class="params">(elementType X, disjSet S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S[X] &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> S[X] = Find(S[X], S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<h5 id="按秩求并和路径压缩的最坏情形"><a href="#按秩求并和路径压缩的最坏情形" class="headerlink" title="按秩求并和路径压缩的最坏情形"></a>按秩求并和路径压缩的最坏情形</h5></blockquote>
<h6 id="Union-Find算法分析"><a href="#Union-Find算法分析" class="headerlink" title="Union/Find算法分析"></a>Union/Find算法分析</h6><ul>
<li><p>引理8.1</p>
<p>当执行一系列Union指令时，一个秩为$r$的节点必然至少有$2^r$个后裔。</p>
</li>
<li><p>引理8.2</p>
<p>秩为$r$的节点的个数最多是$N/2^r$。</p>
</li>
<li><p>引理8.3</p>
<p>在执行这个算法的任意时刻，从树叶到根上的节点的秩单调增加。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构和算法分析 C语言描述》笔记#9 图论算法</title>
    <url>/reports/0dd5623f153c/</url>
    <content><![CDATA[<blockquote>
<h5 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h5></blockquote>
<p>一个<strong>图(Graph)</strong>$G=(V,E)$，由<strong>顶点</strong>$V(Vertex)$的集和<strong>边</strong>$E(Edge)$的集组成。显而易见，每一条边拥有一副点对$(a,b),a,b\in V$。边亦有<strong>弧(arc)</strong>的别称。</p>
<p>图可根据自身属性分为好几种：</p>
<ul>
<li><p>有向(directed)与无向(undirected)</p>
<ul>
<li><p>有向图(digraph)</p>
<p>有向图中，每条边是存在方向性的，如同向量，$(v,w)和(w,v)$是两条不同的边。</p>
<p>我们将一个去掉方向性的有向图称为它的基础图(underlying graph)。</p>
</li>
<li><p>无向图(graph)</p>
<p>无向图中边不存在方向性。</p>
</li>
</ul>
</li>
<li><p>有圈(cyclic)与无圈(acyclic)</p>
<ul>
<li><p>有圈图</p>
<p>因为有向图的方向性，即使是两个点也可以算作一个“扁平”的圈。</p>
<p>而无向图显然必须至少需要三个点才能算作圈。</p>
</li>
<li><p>无圈图</p>
<p>有向无圈图(Direct Acyclic Graph)，常简称DAG。</p>
</li>
</ul>
</li>
<li><p>有权(weight/cost)与无权</p>
</li>
</ul>
<p>​    我们将穿过一条边的代价称作权。当图为无权图时，每条边的权为1。显然，无权是有权的特殊情况。</p>
<ul>
<li><p>连通(connect)</p>
<p>无向图中，如果每个顶点均与其他节点直接连接，则该无向图为连通的(connected)。</p>
<p>而有向图中，如果它的基础图是连通的，那么称其为弱连通(weakly connected)。</p>
<p>如果它本身满足连通的条件，即每个顶点到其他顶点都存在一条路径，则为强连通(strongly connected)。</p>
<p>当每一对顶点间都存在一条边的图称为完全图(complete graph。</p>
</li>
</ul>
<blockquote>
<h5 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h5></blockquote>
<p>我们首先假设有向图的表示，因为有向图往往比无向图复杂的多。</p>
<p>首先可以简单的提出二维数组表示法，我们把这个二维数组称作邻接矩阵(adjacent matrix)。</p>
<p>虽然这种表示很简单，但是当图的边不多，即图并不稠密(dense)，那么这会浪费大量资源。</p>
<p>我们有一个更好的方法来应对这种情况，即邻接表(adjacent list)。在邻接表中每个我们把每个节点相邻的节点存储在一起。这往往通过散列表来实现。</p>
<blockquote>
<h5 id="图的拓扑排序"><a href="#图的拓扑排序" class="headerlink" title="图的拓扑排序"></a>图的拓扑排序</h5></blockquote>
<p>拓扑排序针对DAG。它能根据节点的方向得到一个排序好的节点列表，对同一个图这个排序结果可能不是唯一的。</p>
<p>我们首先提出入度(indegree)和出度的概念以更好的描述拓扑排序：</p>
<ul>
<li><p>入度</p>
<p>入度描述的是一个节点被指向的边的条数，有多少条边指向它，这个节点入度就为多少。</p>
</li>
<li><p>出度</p>
<p>同理，出度描述的是节点指出的边的条数。</p>
</li>
</ul>
<p>因为拓扑排序得到的排序结果第一个节点的入度必然为0，也就是说它指向其他节点，而其他节点不指向它。那么显然的，我们首先需要找出这第一个节点。</p>
<p>书上给出了一种简单的算法描述：</p>
<ol>
<li>找出入度最小的节点，显印它并把它从图中删除（这会更新这个节点指向的节点们的入度）。</li>
<li><p>重复步骤1，直到图不再拥有任何节点。</p>
<p>我们可以在这个基础上提出一些改进：</p>
</li>
<li><p>将所有入度为0的节点单独存放，这样我们不会每次都扫描一遍存放数组的邻接表。</p>
</li>
<li>使用栈或队列来存放这些入度为0的节点，这能利用这些数据结构的特性来方便我们的实现。</li>
</ol>
<p>附上原书的伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topSort</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue Q;<span class="comment">//存放0入度节点的队列</span></span><br><span class="line">    <span class="keyword">int</span> Counter = <span class="number">0</span>;<span class="comment">//拓扑排序得到的每个节点的序号</span></span><br><span class="line">    Vertex V,W;<span class="comment">//选中节点V,和临近节点W</span></span><br><span class="line">    </span><br><span class="line">    Q = createQueue(numOfVertex);<span class="comment">//创建队列</span></span><br><span class="line">    makeEmpty(Q);<span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">for</span> each Vertex V</span><br><span class="line">        <span class="keyword">if</span>(Indegree[V] == <span class="number">0</span>)</span><br><span class="line">            enqueue(V, Q);<span class="comment">//将图中所有入度为0的节点读入队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))<span class="comment">//当队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        V = dequeue(Q);<span class="comment">//弹出一个节点</span></span><br><span class="line">        topNum[V] = ++Counter;<span class="comment">//将这个节点的序号存放到指定数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> each W adjacent to V</span><br><span class="line">            <span class="keyword">if</span>(--Indegree[W]==<span class="number">0</span>)<span class="comment">//如果临近节点在入度更新后入度变为0</span></span><br><span class="line">                enqueue(W, Q);<span class="comment">//临近节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Counter != numOfVertex)<span class="comment">//当完成排序后，发现计数器和节点总数目对不上</span></span><br><span class="line">        error(<span class="string">&quot;Graph has a circle&quot;</span>);<span class="comment">//报错，图有圈，不可拓扑排序</span></span><br><span class="line">    </span><br><span class="line">   disposeQueue(Q);<span class="comment">//解散队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h5 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h5></blockquote>
<ul>
<li><p>无权最短路径</p>
<p>我们在前面已经提到了，无权实际上是所有边权值等于1的特殊有权。</p>
<p>书上使用了广度优先搜索(breadth-first search)，这会按层来处理顶点。</p>
<p>我们设路径起点节点为$s$，每个节点为$v_i$，每个节点到$s$的距离为$d_r$，得到的最短路径每个节点连接用$p_r$。</p>
<p>算法步骤如下：</p>
<ol>
<li>找到尚未访问过的距离起点最近的节点，设置其$d_r$和$p_r$。</li>
<li>重复步骤1，直到所有节点都被遍历。</li>
</ol>
<p>同样可以使用队列来实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unweighted</span><span class="params">(Table T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Vertex V,W;</span><br><span class="line">    </span><br><span class="line">    Q = createQueue(numOfVertex);</span><br><span class="line">    makeEmpty(Q);</span><br><span class="line">    </span><br><span class="line">    enqueue(S, Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        V = dequeue(Q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> each W adjacent to V</span><br><span class="line">            <span class="keyword">if</span>(T[W].Dist == Infinity)</span><br><span class="line">            &#123;</span><br><span class="line">                T[W].Dist = T[V].Dist + <span class="number">1</span>;</span><br><span class="line">                T[W].Path = V;</span><br><span class="line">                enqueue(W, Q);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    disposeQueue(Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>有权最短路径-Dijkstra算法</p>
<p>Dijkstra算法是一种贪婪算法，它分阶段解决问题，但得出的不一定是最优解。</p>
<p>算法步骤如下：</p>
<ol>
<li>找出与上一个节点（显然一开始是$s$节点）邻接节点中权值最小的节点，访问该节点，设置其$d_w$为自身权值加上$d_v$。(注意，被访问过的节点将无法被更新$d_v$，这是这个算法的缺点之一)</li>
<li>重复步骤1，若对一个节点多次处理，则$d_w$取最小值。</li>
</ol>
</li>
<li><p>负边值的图</p>
<p>前面提到的Dijkstra算法对于负边值图并不管用，因为它无法更新访问过的节点。显然的，我们给所有权值加上一个足够大的常数让它们不为负不会解决问题，大的仍然会更大，$d_v$不会有更小的可能。</p>
<p>一个好的想法是让被访问过的节点仍能被更新，也就是说每个节点可能会被多次访问和更新。但是这种办法不适用于拥有负值圈的图，因为负值圈内的权值会越来越小，永无止境。如果要解决这个问题，我们可以指定每个节点最大的访问次数。</p>
</li>
<li><p>无圈图</p>
<p>实际上，我们可以把无圈图看作树，或者说，树就是无圈图。</p>
<p>无圈图的典型运用是关键路径分析法(critical path analysis)。</p>
</li>
</ul>
<blockquote>
<h5 id="网络流问题"><a href="#网络流问题" class="headerlink" title="网络流问题"></a>网络流问题</h5></blockquote>
<p>  网络流问题处理的是一般是最大流问题。我们可以将边看作管道，图中的每个边都有自己的最大流量，只允许通过固定的流。而节点存在两个特殊的节点，一个是发点(sorce)，可以看作水龙头，一个是收点(sink)，可以看作一个装水的容器（锅碗瓢盆）。我们的目的就是计算出这个系统瞬时能通过的最大流量。</p>
<p>  书上提出了一种和拓扑排序相似的最大流问题解法：</p>
<p>  我们复制两份原图，分别称为流图和残余图(residual graph)。</p>
<p>  当图中任意一条边达到最大流量，我们就将其从残余图中删去。而无论是否达到最大流量，只要有流通过边，我们就在流图上的对应边上标注通过的流量。</p>
<p>  这样便让最大流问题简单的化为了消边问题，为了保证发点到收点的路径必然存在，我们必然要通过路径上的最小容量的边。</p>
<p>  为了让算法能顺利的进行，我们可以在残余图上标注和边相反方向的箭头和数字来表示一条边上的剩余可用容量。</p>
<blockquote>
<h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5></blockquote>
<p>一棵最小生成树是包含了所有节点，并且总权值最小，所有节点直接或间接连接。</p>
<ul>
<li><p>Prim算法</p>
<p>该算法让这棵树一步步成长。这和Dijikstra算法十分相似，不过这里每个边的$d_v$都可以被更新，因为它要确保最小值。</p>
</li>
<li><p>Kruskal算法</p>
<p>该算法连续按最小的权选择边，并且当所选边不产生圈时就作为取定的边。如果两个节点不在同一个集合，就实行Union操作</p>
</li>
</ul>
<blockquote>
<h5 id="深度优先搜索的应用"><a href="#深度优先搜索的应用" class="headerlink" title="深度优先搜索的应用"></a>深度优先搜索的应用</h5></blockquote>
<p>深度优先搜索(depth-first search)是对先序遍历的一般化。</p>
<ul>
<li><p>无向图</p>
<p>我们将开始节点标记为已访问，并递归调用Dfs(下一个节点)。任何被访问过的节点都会被标记为已访问，并在未来不再被访问。</p>
</li>
<li><p>双连通性</p>
<p>首先我们需要介绍割点(articulation point)的概念，割点是特殊的节点，被删除后会使得图不再是连通的（换句话说，就是图中剩余节点不再直接或间接连接）。</p>
<p>当一个连通的无向图中不存在割点，我们便称这样的无向连通图为双连通(biconnected)。</p>
</li>
<li><p>欧拉回路/欧拉路径/欧拉环游</p>
<p>于数学界欧拉在1736年解决的问题，标志着图论的诞生。欧拉回路问题可以理解为一笔画，图中的每条边只能走一遍，但必须访问过所有节点。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Dot入门1</title>
    <url>/notes/6b6867c78250/</url>
    <content><![CDATA[<h4 id="1-关于安装"><a href="#1-关于安装" class="headerlink" title="1. 关于安装"></a>1. 关于安装</h4><p>你可以去Graphviz<a href="https://graphviz.org/">官方网站</a>找到各个系统的下载方式，并且在官网有对这个软件更详细的说明。安装非常简单，只需要一路确认即可。</p>
<h4 id="2-关于编译"><a href="#2-关于编译" class="headerlink" title="2. 关于编译"></a>2. 关于编译</h4><p>你可以通过命令行快速得到渲染后的图像文件。命令如下：</p>
<p><code>cmd [ flags ] [ input files ]</code></p>
<p><code>cmd</code>为你想要使用的渲染方式，Graphviz提供的渲染方式有下列几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>dot</code></td>
<td style="text-align:left">渲染的图具有明确方向性。</td>
</tr>
<tr>
<td style="text-align:left"><code>osage</code></td>
<td style="text-align:left">渲染的图是集群的矩形。</td>
</tr>
<tr>
<td style="text-align:left"><code>neato</code></td>
<td style="text-align:left">渲染的图缺乏方向性。</td>
</tr>
<tr>
<td style="text-align:left"><code>twopi</code></td>
<td style="text-align:left">渲染的图采用放射性布局。</td>
</tr>
<tr>
<td style="text-align:left"><code>circo</code></td>
<td style="text-align:left">渲染的图采用环型布局。</td>
</tr>
<tr>
<td style="text-align:left"><code>fdp</code></td>
<td style="text-align:left">渲染的图缺乏方向性。</td>
</tr>
<tr>
<td style="text-align:left"><code>sfdp</code></td>
<td style="text-align:left">渲染大型的图，图片缺乏方向性。</td>
</tr>
<tr>
<td style="text-align:left"><code>patchwork</code></td>
<td style="text-align:left">渲染如Treemaps的集群图表。</td>
</tr>
</tbody>
</table>
</div>
<p>详细可以见<a href="https://graphviz.org/about/">官方说明</a>。</p>
<p><code>[ flags ]</code>是想要加上的参数。</p>
<p>常见的有：</p>
<p><code>-T</code>: 设定输出的格式/后缀名。</p>
<p><code>-o</code>: 设定输出的文件名。</p>
<p><code>-O</code>: 根据输入的文件名输出文件，并且支持<code>-T</code>多格式输出。</p>
<p><code>-s</code>: 指定一个特定的输出比例大小。</p>
<p>更多参数可以在<a href="https://graphviz.org/doc/info/command.html">官方文档</a>查看。</p>
<p>如果你不想要这样麻烦的操作，这里有两种可能更好的方法：</p>
<ol>
<li><p>使用vs code中<code>João Pinto</code>编写的<code>Graphviz (dot) language support for Visual Studio Code</code>插件。这个插件允许你在右侧实时渲染你的图表，十分便利。</p>
</li>
<li><p>使用<a href="https://www.gravizo.com/"><code>Gravizo</code></a>。这是一个在线渲染图表的网站，允许你通过在Markdown中通过图片插入功能得到在线的即时渲染。</p>
<p>使用十分简单，只需正常图片插入操作即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">![blabla](https:<span class="comment">//g.gravizo.com/svg? 你的图表)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">例子： ![blabla](https:<span class="comment">//g.gravizo.com/svg? digraph g &#123;</span></span><br><span class="line">       splines = <span class="string">&quot;polyline&quot;</span>;</span><br><span class="line">    k2:s-&gt;k1:n [arrowhead=normal;color=<span class="string">&quot;green&quot;</span>;len=<span class="number">2</span>;style=<span class="string">&quot;polyline&quot;</span>];</span><br><span class="line">       k2:s-&gt;Z:n [arrowhead=normal;color=<span class="string">&quot;green&quot;</span>;len=<span class="number">2</span>];</span><br><span class="line">       k1:s-&gt;X:n [arrowhead=normal;color=<span class="string">&quot;red&quot;</span>;];</span><br><span class="line">       k1:s-&gt;Y:n [arrowhead=normal;color=<span class="string">&quot;green&quot;</span>;];</span><br><span class="line">       k1,k2 [shape=circle;];</span><br><span class="line">       Z,Y [shape=triangle;height=<span class="number">1</span>;]</span><br><span class="line">       X [shape=triangle;height=<span class="number">2</span>;]</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
<p>![blabla](<a href="https://g.gravizo.com/svg?">https://g.gravizo.com/svg?</a> digraph g {</p>
<pre><code>splines = &quot;polyline&quot;;
k2:s-&gt;k1:n [arrowhead=normal;color=&quot;green&quot;;len=2;style=&quot;polyline&quot;];
k2:s-&gt;Z:n [arrowhead=normal;color=&quot;green&quot;;len=2];
k1:s-&gt;X:n [arrowhead=normal;color=&quot;red&quot;;];
k1:s-&gt;Y:n [arrowhead=normal;color=&quot;green&quot;;];
k1,k2 [shape=circle;];
Z,Y [shape=triangle;height=1;]
X [shape=triangle;height=2;]
</code></pre><p>})</p>
<p>你也可以直接得到图片，只需将你的图表描述进行url编码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">![blabla](https:<span class="comment">//g.gravizo.com/source/svg?&lt;source_url_url_encoded&gt;)</span></span><br></pre></td></tr></table></figure>
<p>顺便一提，<a href="https://www.gravizo.com/"><code>Gravizo</code></a>不仅支持<a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language">DOT</a>),还支持<a href="http://plantuml.sourceforge.net/sequence.html">PlantUML</a> 和 <a href="http://www.umlgraph.org/doc/cd-model.html">UMLGraph</a>的语法！</p>
<p>但遗憾的是，简书并不支持<a href="https://www.gravizo.com/"><code>Gravizo</code></a>。</p>
</li>
</ol>
<h4 id="3-入门操作"><a href="#3-入门操作" class="headerlink" title="3. 入门操作"></a>3. 入门操作</h4><ol>
<li><p>节点(node)、线(edge)、图(graph)</p>
<blockquote>
<p>节点</p>
</blockquote>
<p>节点是一个独立的单位，它包含了数据并拥有自己的属性。你可以设置节点的形状、大小和颜色等属性。</p>
<p>你可以给每个节点都设置一个独特的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diagraph example3&#123;</span><br><span class="line">	<span class="string">&quot;iamanode&quot;</span> [color=<span class="string">&quot;red&quot;</span>,shape=circle];</span><br><span class="line">    <span class="string">&quot;iamsame&quot;</span> [label=<span class="string">&quot;Nodeiam&quot;</span>;fontsize=<span class="number">28</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性之间允许使用<code>,</code>或<code>;</code>分隔。另外，最好给节点名加上引号，以防止一些不必要的麻烦。</p>
<p>但你也可给所有的节点一个默认的属性，这个默认属性会被节点自身单独设定的属性覆盖：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diagraph example3_1&#123;</span><br><span class="line">	node [color=<span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线</p>
</blockquote>
<p>线连接了两个节点。通过属性你可以控制线的外观（大小，粗细等样式），指向等等设置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diagraph example3_2&#123;</span><br><span class="line">	a-&gt;b [color=<span class="string">&quot;red&quot;</span>,style=<span class="string">&quot;dotted&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你同样可以给它一个基础的样式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diagraph example3_3&#123;</span><br><span class="line">	edge [style=<span class="string">&quot;dotted&quot;</span>,arrowhead=<span class="string">&quot;normal&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>图</p>
</blockquote>
<p>图分为有向图(diagraph)和无向图(graph)。</p>
<ul>
<li><p>有向图</p>
<p>有向图以<code>diagraph</code>开始，脚本中的线条用<code>-&gt;</code>表示。在有向图里面，所有的边都默认是存在箭头即有向的（但我们还是可以通过调整边的属性去掉箭头）。前面的例子都是有向图，不再赘述。</p>
</li>
<li><p>无向图</p>
<p>无向图以<code>graph</code>开始，脚本中的线条用<code>--</code>表示。在有向图里面，所有的边都默认无向。性质基本和有向图相同。</p>
</li>
</ul>
<p>你在一个文件里只能建立一个的图，或者说一个文件是一个画板，在一个画板上只能容纳一副图表。</p>
<p>但是你可以通过建立子图的方式，来某种意义上变相地容纳多个图，这有点类似于Java中内部类的概念。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diagraph example3_4&#123;</span><br><span class="line">	subgraph cluster1&#123;</span><br><span class="line">		k1-&gt;k2 [color=grey];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，子图必须以<code>cluster</code>开头命名，否则只是单纯的一个大括号。一个正常的子图是拥有自己的边框的，当边框不存在，很可能你的语法出现了错误。顺便一提，在一张图中，节点名是唯一的。</p>
</li>
</ol>
<h4 id="4-高级操作"><a href="#4-高级操作" class="headerlink" title="4. 高级操作"></a>4. 高级操作</h4><p>在看完前面的例子后，我们应该就能画出一些简单的表格。但是可能有一些人对程序生成的表格并不满意，比如连接节点的线不是直线而是弯曲的曲线，节点的形状不是自己所求，或者追求更细致的图表。</p>
<ul>
<li><blockquote>
<p>节点的<code>shape</code>属性</p>
</blockquote>
<p>我们可以通过<code>shape</code>属性将节点设置成不同形状！这里可不只有圆形矩形和三角形。</p>
<p>Graphviz提供了许多基于多边形的预设形状，如star，folder，note等等。除此之外你还可以自定义一个多边形，这里简单分享一个自定义多边形的实例：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">digraph example4_1 &#123;</span><br><span class="line">    splines = <span class="string">&quot;polyline&quot;</span>;</span><br><span class="line">    border = line;</span><br><span class="line">    subgraph x&#123;</span><br><span class="line">        polygon </span><br><span class="line">        [</span><br><span class="line">        <span class="attribute">shape</span>=<span class="string">&quot;polygon&quot;</span>;</span><br><span class="line">        <span class="attribute">sides</span>=9;</span><br><span class="line">        <span class="attribute">skew</span>=0.0;</span><br><span class="line">        <span class="attribute">distortion</span>=0.0;</span><br><span class="line">        <span class="attribute">regular</span>=<span class="literal">false</span>;</span><br><span class="line">        <span class="attribute">peripheries</span>=3;</span><br><span class="line">        <span class="attribute">orientation</span>=180;</span><br><span class="line">        <span class="attribute">style</span>=rounded</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>sides</code>边数</p>
</blockquote>
<p>这个属性仅可用于<code>shape=polygon</code>的情况，其默认值为<code>4</code>，呈现为一个矩形。</p>
<blockquote>
<p><code>skew</code>倾斜/偏移</p>
</blockquote>
<p>这个属性仅可用于<code>shape=polygon</code>的情况，其默认值为<code>0.0</code>。当其为正数时，节点上半部分向右偏移；当为负数时，节点的上半部分向左偏移。</p>
<blockquote>
<p><code>distortion</code>扭曲</p>
</blockquote>
<p>这个属性仅可用于<code>shape=polygon</code>的情况，其默认值为<code>0.0</code>。当其为正数时，节点上半部分左右扩张；当为负数时，节点的上半部分左右缩小。变形后的上半部分长度计算方式为<code>1 + distortion</code>。</p>
<blockquote>
<p><code>regular</code>规则度</p>
</blockquote>
<p>这个属性仅可用于<code>shape=polygon</code>的情况，其默认值为<code>false</code>。当其为<code>true</code>时，节点形状呈现为正多边形；当为<code>false</code>时，节点呈现为非正多边形。</p>
<blockquote>
<p><code>peripheries</code>边界条数</p>
</blockquote>
<p>这个属性对于基于多边形的形状都适用，其默认值为<code>1</code>。值得一提是，对于用户自己创建加载的形状，这个属性可能会导致渲染出现错误，这时候应将其设置为<code>0</code>以取消默认的边界。</p>
<blockquote>
<p><code>orientation</code>旋转</p>
</blockquote>
<p>这个属性仅可用于<code>shape=polygon</code>的情况，其默认值为<code>0.0</code>。当其为正数时，节点向左旋转；当为负数时，节点向右旋转。旋转的角度为该属性的值。</p>
<blockquote>
<p><code>styl=rounded</code>圆角</p>
</blockquote>
<p>这个属性适用于所有节点，但是对于本身有圆角的图形可能不会有显现。另外，一个属性只能有一个值。</p>
</li>
<li><blockquote>
<p><code>shape=record</code>基于record的形状与锚点</p>
</blockquote>
<p>这个形状允许你将一个矩形通过内在的线分为好几部分。语法十分简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">digraph example4_2 &#123;</span><br><span class="line">	node01 [shape=record;label=<span class="string">&quot;左 | 中 | 右&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们甚至可以更细分：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">digraph example4_2_1 &#123;</span><br><span class="line">	node02 [shape=<span class="keyword">record</span>;label=<span class="string">&quot;左 |&#123; 中上 |&#123;a | b | c&#125;| 中下 &#125;| 右&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提示：每内嵌一次<code>&#123;&#125;</code>，分割的方向便会横竖旋转一次。</p>
<p>如果我们想要其他节点不只是指向这个节点，而指向这些被分割出的部分，我们可以使用锚点：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">digraph example<span class="number">4</span>_<span class="number">2</span>_<span class="number">2</span> &#123;</span><br><span class="line">	<span class="symbol">node01</span> [shape=record;label=<span class="string">&quot;&lt;ybyb&gt;左 | &lt;yb8bo&gt;右&quot;</span>]</span><br><span class="line">    <span class="symbol">node01</span>:ybyb -&gt; <span class="symbol">node01</span>:yb<span class="number">8</span>bo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提，锚点的声明一定要写在实际内容前面！</p>
</li>
<li><blockquote>
<p>节点的<code>overflow</code>现象</p>
</blockquote>
<p>默认来说，节点中的文字不会溢出边界。事实上，节点形状大小会被文字内容给撑大，在这种情况下的<code>width</code>和<code>height</code>属性不会生效。为了让特定的高度和宽度生效，我们必须设置节点的<code>fixedsize</code>属性。</p>
<p><code>fixedsize</code>属性有三个值，分别是<code>true</code>、<code>false</code>、<code>shape</code>。</p>
<ul>
<li><p><code>fixedsize=false</code></p>
<p>这种情况下，倘若没有给出高度与宽度或者小于包围其文字内容的最小大小，节点形状的大小将按照包围其文字内容的最小大小计算。当给出的高度与宽度大于最小高宽，将按照给出的高宽变形。</p>
</li>
<li><p><code>fixedsize=true</code></p>
<p>节点形状只与给定的高度与宽度有关，倘若过小，节点的文字内容会超出边界，甚至覆盖到其他节点上去，值得警惕。</p>
</li>
<li><p><code>fixedsize=shape</code></p>
<p>和<code>fixedsize=true</code>情况类似，但是不会覆盖到其他节点，反而会将其他节点推开。不过在高宽过大时，边可能穿过节点边界指向文字内容。</p>
</li>
</ul>
</li>
<li><blockquote>
<p>图的布局</p>
</blockquote>
<ul>
<li><blockquote>
<p><code>rankdir</code>改变图的排列方向</p>
</blockquote>
<p>我们可以通过改变图的属性 <code>rankdir</code>来改变图的排列方向。图默认为<code>rankdir=TB</code>，即从top到bottom；为了让它能左右排列，我们可以改为<code>rankdir=LR</code>。</p>
</li>
<li><blockquote>
<p><code>rank</code>改变节点的位置</p>
</blockquote>
<p>当我们画完一张图的时候，可能会发现图中一些本应该排成一排或一列的节点没有在自己正确的位置。这种时候我们可以通过域和<code>rank</code>属性来修正。在<code>rank</code>中，左上为最小，右下为最大。</p>
<ul>
<li><p><code>sink</code>和<code>max</code></p>
<p>当<code>rank</code>被设置为<code>sink</code>和<code>max</code>时，节点都会沉到最底部。但是<code>max</code>比<code>sink</code>对相邻节点的影响更大。</p>
</li>
<li><p><code>source</code>和<code>min</code></p>
<p>当<code>rank</code>被设置为<code>source</code>和<code>min</code>时，节点都会上升至顶部。<code>source</code>只允许<code>rank</code>为<code>source</code>或<code>min</code>的位置处于最小阶，而<code>min</code>则不会排斥其他节点，但实际上两者带来的效果几乎没有差别。</p>
</li>
<li><p><code>same</code></p>
<p>让所有的节点都处于同一阶。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">digraph example4_3 &#123;</span><br><span class="line">	X-&gt;Y-&gt;Z;</span><br><span class="line">    &#123;</span><br><span class="line">        X,Z;</span><br><span class="line">        rank=same</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><blockquote>
<p><code>fill</code>为节点填色</p>
</blockquote>
<p>  有时候我们想要得到彩色背景的节点，而不仅仅只是通过<code>color</code>改变节点边的颜色。</p>
<p>  通过<code>style=filled</code>和<code>fillcolor=red</code>属性可以改变这一点。</p>
  <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">digraph </span>example4_4 &#123;</span><br><span class="line">    <span class="built_in">k1</span> [color=<span class="keyword">blue;style=filled;fillcolor=black;fontcolor=white]</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><blockquote>
<p><code>portPos</code>改变边的指向</p>
</blockquote>
<p>  我们可以让边从一个节点的北部出发，指向一个节点的南部。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">digraph example4_5 &#123;</span><br><span class="line">    k2:s-&gt;k1:n [arrowhead=none;color=<span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里我通过 arrowhead 取消了边的箭头，更多边的属性请查阅官方文档</span></span><br></pre></td></tr></table></figure>
<p>  这里的方向有：<code>&quot;n&quot;,&quot;ne&quot;,&quot;e&quot;,&quot;se&quot;,&quot;s&quot;,&quot;sw&quot;,&quot;w&quot;,&quot;nw&quot;,&quot;c&quot;,&quot;_&quot;</code>。<code>e,s,w,n</code>东南西北，<code>ne,se,sw,nw</code>同理。这里需要解释的是<code>c</code>和<code>_</code>。</p>
<p>  <code>c</code>指的是从节点的中心指出或者指入。</p>
<p>  <code>_</code>则是让程序自己寻找一个可能的值，在空间允许的情况下和<code>c</code>同效果。</p>
</li>
<li><blockquote>
<p>边的<code>style</code>属性</p>
</blockquote>
<p><code>solid</code>默认的实线，<code>dashed</code>虚线，<code>dotted</code>点线，<code>bold</code>粗线，<code>tapered</code>锥形线，<code>invis</code>不可见。</p>
</li>
<li><blockquote>
<p>在<code>lable</code>中使用HTML标签</p>
</blockquote>
<p><code>lable</code>属性值现在支持HTML标签，你可以用HTML标签对文字的样式进行修改（包括大小，颜色，字体，对齐甚至渐变）。<a href="https://graphviz.org/doc/info/shapes.html">详情请见官方文档</a>。</p>
</li>
<li><blockquote>
<p><code>splines</code>改变线的形状</p>
</blockquote>
<ul>
<li><blockquote>
<p><code>true/spline</code></p>
</blockquote>
<p>这是默认属性。这将使得边为样条线，即可曲可直，可能为了指向终点穿过节点。</p>
</li>
<li><blockquote>
<p><code>false/line</code></p>
</blockquote>
<p>当被设置为<code>false</code>或<code>line</code>时，边只为直线段，也可能为了指向终点穿过节点，“直来直去”。</p>
</li>
<li><blockquote>
<p><code>polyline</code></p>
</blockquote>
<p>折线，保证所有边都为直线，边会通过折来转向，但转向角度不一定时90度。</p>
</li>
<li><blockquote>
<p><code>ortho</code></p>
</blockquote>
<p>折线，保证所有边都为直线，转向角度为90度，可能为了指向终点穿过节点。</p>
</li>
<li><blockquote>
<p><code>curved</code></p>
</blockquote>
<p>曲线，保证所有边都为曲线，可能为了指向终点穿过节点。</p>
</li>
<li><p><code>none</code>/<code>“”</code></p>
<p>不显示边。</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-查阅资料"><a href="#5-查阅资料" class="headerlink" title="5. 查阅资料"></a>5. 查阅资料</h4><ol>
<li>官网<ol>
<li><a href="https://graphviz.org/doc/info/shapes.html"><code>shape</code>属性查询</a></li>
<li><a href="https://graphviz.org/doc/info/attrs.html"><code>attr</code>各个属性详略解释</a></li>
</ol>
</li>
<li>博客/QA平台</li>
</ol>
<h4 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h4><ol>
<li><a href="https://graphviz.org/">graphviz官网</a></li>
<li><a href="https://stackoverflow.com/questions/31182987/polylines-edges-when-using-ports-graphviz">stackflow-polylinesedges when using ports graphviz</a></li>
<li><a href="https://blog.csdn.net/Edisonleeee/article/details/90214143">Graphviz 画图教程 by EdisonLeejt</a></li>
<li><a href="http://hustlijian.github.io/tutorial/2015/05/29/graphviz-learn.html?utm_source=tuicool&amp;utm_medium=referral">绘图工具graphviz学习使用 by hustlijian</a></li>
<li><a href="https://www.cnblogs.com/shuqin/p/11897207.html">Graphviz 画图的一些总结 by 小胖西瓜</a></li>
<li><a href="https://itopic.org/graphviz.html">Graphviz绘图 - DOT语言 by 老彭</a></li>
<li><a href="https://www.cnblogs.com/itzxy/p/7860165.html">使用DOT语言和Graphviz绘图(翻译) by Tony Ballantyne 和 zxyblog</a></li>
</ol>
<p>感谢他们的思考与无私分享。</p>
]]></content>
      <categories>
        <category>经验笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>dot</tag>
      </tags>
  </entry>
</search>
